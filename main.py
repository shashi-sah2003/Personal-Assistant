import os
import sys
import json
import schedule
import time
from datetime import datetime
from pathlib import Path
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from src.agents.workflow import run_personal_assistant
from src.api.jira_endpoints import router as jira_router

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))


app = FastAPI(
    title="GEP Personal Assistant API",
    description="API for interacting with various workplace services including JIRA, Email, Calendar, and Teams.",
    version="1.0.0"
)

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.include_router(jira_router)


def generate_daily_summary(use_mock_data=False):
    """Generate the daily summary and save it to a file
    
    Args:
        use_mock_data (bool): Whether to use mock data instead of real API calls
    """
    print(f"Generating daily summary at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"{'Using mock data' if use_mock_data else 'Using real API data'}")
    
    try:
        result = run_personal_assistant(use_mock_data=use_mock_data)
        
        output_dir = Path("output")
        output_dir.mkdir(exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
        output_file = output_dir / f"daily_summary_{timestamp}.md"
        
        summary = f"""# Daily Summary - {datetime.now().strftime('%Y-%m-%d')}

## Executive Summary
{result['final_summary']}

---

## Email Summary
{result['email_summary']}

---

## Meeting Schedule
{result['calendar_summary']}

---

## JIRA Tickets
{result['jira_summary']}

---

## Teams Messages
{result['teams_summary']}

---

*Generated by Personal Assistant at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*
"""
        
        with open(output_file, "w", encoding="utf-8") as f:
            f.write(summary)
            
        print(f"Daily summary saved to {output_file}")
        
        with open(output_dir / f"daily_summary_{timestamp}.json", "w", encoding="utf-8") as f:
            json.dump(result, f, indent=4)
            
        return summary
        
    except Exception as e:
        error_message = f"Error generating daily summary: {str(e)}"
        print(error_message)
        
        output_dir = Path("output")
        output_dir.mkdir(exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
        error_file = output_dir / f"error_log_{timestamp}.txt"
        
        with open(error_file, "w", encoding="utf-8") as f:
            f.write(error_message)
            
        return error_message

def schedule_daily_summary(hour=8, minute=30, use_mock_data=False):
    """Schedule the daily summary to run at a specific time
    
    Args:
        hour (int): Hour to run (24-hour format)
        minute (int): Minute to run
        use_mock_data (bool): Whether to use mock data instead of real API calls
    """
    schedule.every().day.at(f"{hour:02d}:{minute:02d}").do(lambda: generate_daily_summary(use_mock_data))
    print(f"Daily summary scheduled to run at {hour:02d}:{minute:02d} every day")
    print(f"{'Using mock data' if use_mock_data else 'Using real API data'}")

def run_once(use_mock_data=False):
    """Run the daily summary once
    
    Args:
        use_mock_data (bool): Whether to use mock data instead of real API calls
    """
    return generate_daily_summary(use_mock_data=use_mock_data)

if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description="Personal Assistant")
    parser.add_argument("--schedule", action="store_true", 
                        help="Schedule the daily summary to run at a specific time")
    parser.add_argument("--hour", type=int, default=8,
                        help="Hour to run the scheduled summary (24-hour format)")
    parser.add_argument("--minute", type=int, default=30,
                        help="Minute to run the scheduled summary")
    parser.add_argument("--run-once", action="store_true",
                        help="Run the daily summary once and exit")
    parser.add_argument("--mock", action="store_true",
                        help="Use mock data instead of real API calls")
    args = parser.parse_args()
    
    if args.run_once:
        print("\n" + "="*80)
        print(f"Starting Personal Assistant - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("="*80 + "\n")
        
        summary = run_once(use_mock_data=args.mock)
        
        print("\n" + "="*80 + "\n")
        print(summary)
        print("\n" + "="*80)
        print("Personal Assistant completed successfully!")
        print("="*80 + "\n")
    elif args.schedule:
        schedule_daily_summary(args.hour, args.minute, use_mock_data=args.mock)
        
        print(f"\n{'='*80}")
        print(f"Personal Assistant Scheduler started at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"Next summary will be generated at {args.hour:02d}:{args.minute:02d}")
        print(f"{'='*80}\n")
        print("Press Ctrl+C to stop the scheduler")
        
        try:
            while True:
                schedule.run_pending()
                time.sleep(60) 
        except KeyboardInterrupt:
            print("\nScheduler stopped.")
    else:
        print("\n" + "="*80)
        print("Please specify either --run-once or --schedule")
        print("="*80 + "\n")
        parser.print_help()


